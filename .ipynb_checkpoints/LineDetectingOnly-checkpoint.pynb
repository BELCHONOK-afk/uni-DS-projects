{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ff343ef5",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import cv2\n",
    "import time\n",
    "from threading import Thread\n",
    "from queue import Queue\n",
    "\n",
    "# defualt video number, if you want to process the \"fog_video.mp4\", change video_index to 1\n",
    "video_index = 1\n",
    "\n",
    "# the result of lane detection, we add the road to the main frame\n",
    "road = np.zeros((720, 1280, 3))\n",
    "\n",
    "# A flag which means the process is started\n",
    "started = 0\n",
    "\n",
    "# Pipeline combining color and gradient thresholding"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "af9db603",
   "metadata": {},
   "outputs": [],
   "source": [
    "def thresholding_pipeline(img, s_thresh=(90, 255), sxy_thresh=(20, 100)):\n",
    "\n",
    "    img = np.copy(img)\n",
    "    # 1: Convert to HSV color space and separate the V channel\n",
    "    hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS).astype(np.float)\n",
    "    h_channel = hls[:, :, 0]\n",
    "    l_channel = hls[:, :, 1]\n",
    "    s_channel = hls[:, :, 2]\n",
    "\n",
    "    # 2: Calculate x directional gradient\n",
    "    sobelx = cv2.Sobel(l_channel, cv2.CV_64F, 1, 0)  # Take the derivative in x\n",
    "    # Absolute x derivative to accentuate lines away from horizontal\n",
    "    abs_sobelx = np.absolute(sobelx)\n",
    "    scaled_sobelx = np.uint8(255 * abs_sobelx / np.max(abs_sobelx))\n",
    "    sxbinary = np.zeros_like(scaled_sobelx)\n",
    "    sxbinary[(scaled_sobelx >= sxy_thresh[0]) &\n",
    "             (scaled_sobelx <= sxy_thresh[1])] = 1\n",
    "    grad_thresh = sxbinary\n",
    "\n",
    "    # 3: Color Threshold of s channel\n",
    "    s_binary = np.zeros_like(s_channel)\n",
    "    s_binary[(s_channel >= s_thresh[0]) & (s_channel <= s_thresh[1])] = 1\n",
    "\n",
    "    # 4: Combine the two binary thresholds\n",
    "    combined_binary = np.zeros_like(grad_thresh)\n",
    "    combined_binary[(s_binary == 1) | (grad_thresh == 1)] = 1\n",
    "\n",
    "    return combined_binary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c9d34aca",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Apply perspective transformation to bird's eye view\n",
    "\n",
    "\n",
    "def perspective_transform(img, src_mask, dst_mask):\n",
    "\n",
    "    img_size = (img.shape[1], img.shape[0])\n",
    "    src = np.float32(src_mask)\n",
    "    dst = np.float32(dst_mask)\n",
    "    M = cv2.getPerspectiveTransform(src, dst)\n",
    "    warped_img = cv2.warpPerspective(img, M, img_size, flags=cv2.INTER_LINEAR)\n",
    "    return warped_img\n",
    "\n",
    "\n",
    "# Implement Sliding Windows and Fit a Polynomial\n",
    "def sliding_windows(binary_warped, nwindows=9):\n",
    "\n",
    "    histogram = np.sum(\n",
    "        binary_warped[int(binary_warped.shape[0]/2):, :], axis=0)\n",
    "\n",
    "    # Find the peak of the left and right halves of the histogram\n",
    "    # These will be the starting point for the left and right lines\n",
    "    midpoint = np.int(histogram.shape[0]/2)\n",
    "    leftx_base = np.argmax(histogram[:midpoint])\n",
    "    rightx_base = np.argmax(histogram[midpoint:]) + midpoint\n",
    "\n",
    "    # Set height of windows\n",
    "    window_height = np.int(binary_warped.shape[0]/nwindows)\n",
    "    # Identify the x and y positions of all nonzero pixels in the image\n",
    "    nonzero = binary_warped.nonzero()\n",
    "    nonzeroy = np.array(nonzero[0])\n",
    "    nonzerox = np.array(nonzero[1])\n",
    "    # Current positions to be updated for each window\n",
    "    leftx_current = leftx_base\n",
    "    rightx_current = rightx_base\n",
    "    # Set the width of the windows +/- margin\n",
    "    margin = 100\n",
    "    # Set minimum number of pixels found to recenter window\n",
    "    minpix = 50\n",
    "    # Create empty lists to receive left and right lane pixel indices\n",
    "    left_lane_inds = []\n",
    "    right_lane_inds = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "477c102f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "    # Step through the windows one by one\n",
    "    for window in range(nwindows):\n",
    "        # Identify window boundaries in x and y (and right and left)\n",
    "        win_y_low = binary_warped.shape[0] - (window+1)*window_height\n",
    "        win_y_high = binary_warped.shape[0] - window*window_height\n",
    "        win_xleft_low = leftx_current - margin\n",
    "        win_xleft_high = leftx_current + margin\n",
    "        win_xright_low = rightx_current - margin\n",
    "        win_xright_high = rightx_current + margin\n",
    "        # Identify the nonzero pixels in x and y within the window\n",
    "        good_left_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (\n",
    "            nonzerox >= win_xleft_low) & (nonzerox < win_xleft_high)).nonzero()[0]\n",
    "        good_right_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (\n",
    "            nonzerox >= win_xright_low) & (nonzerox < win_xright_high)).nonzero()[0]\n",
    "        # Append these indices to the lists\n",
    "        left_lane_inds.append(good_left_inds)\n",
    "        right_lane_inds.append(good_right_inds)\n",
    "        # If you found > minpix pixels, recenter next window on their mean position\n",
    "        if len(good_left_inds) > minpix:\n",
    "            leftx_current = np.int(np.mean(nonzerox[good_left_inds]))\n",
    "        if len(good_right_inds) > minpix:\n",
    "            rightx_current = np.int(np.mean(nonzerox[good_right_inds]))\n",
    "\n",
    "    # Concatenate the arrays of indices\n",
    "    left_lane_inds = np.concatenate(left_lane_inds)\n",
    "    right_lane_inds = np.concatenate(right_lane_inds)\n",
    "\n",
    "    # Extract left and right line pixel positions\n",
    "    leftx = nonzerox[left_lane_inds]\n",
    "    lefty = nonzeroy[left_lane_inds]\n",
    "    rightx = nonzerox[right_lane_inds]\n",
    "    righty = nonzeroy[right_lane_inds]\n",
    "\n",
    "    # Fit a second order polynomial to each\n",
    "    left_fit = np.polyfit(lefty, leftx, 2)\n",
    "    right_fit = np.polyfit(righty, rightx, 2)\n",
    "\n",
    "    return left_fit, right_fit, lefty, leftx, righty, rightx\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3ce32b9e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Warp lane line projection back to original image\n",
    "def project_lanelines(binary_warped, orig_img, left_fit, right_fit, dst_mask, src_mask):\n",
    "\n",
    "    global road\n",
    "    global started\n",
    "    ploty = np.linspace(0, binary_warped.shape[0]-1, binary_warped.shape[0])\n",
    "    left_fitx = left_fit[0]*ploty**2 + left_fit[1]*ploty + left_fit[2]\n",
    "    right_fitx = right_fit[0]*ploty**2 + right_fit[1]*ploty + right_fit[2]\n",
    "\n",
    "    # Create an image to draw the lines on\n",
    "    warp_zero = np.zeros_like(binary_warped).astype(np.uint8)\n",
    "    color_warp = np.dstack((warp_zero, warp_zero, warp_zero))\n",
    "\n",
    "    # Recast the x and y points into usable format for cv2.fillPoly()\n",
    "    pts_left = np.array([np.transpose(np.vstack([left_fitx, ploty]))])\n",
    "    pts_right = np.array(\n",
    "        [np.flipud(np.transpose(np.vstack([right_fitx, ploty])))])\n",
    "    pts = np.hstack((pts_left, pts_right))\n",
    "\n",
    "    # Draw the lane onto the warped blank image\n",
    "    cv2.fillPoly(color_warp, np.int_([pts]), (0, 255, 0))\n",
    "    # Warp the blank back to original image space using inverse perspective matrix (Minv)\n",
    "    warped_inv = perspective_transform(color_warp, dst_mask, src_mask)\n",
    "    road = warped_inv\n",
    "    started = 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d00ec617",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Main process functions\n",
    "\n",
    "\n",
    "def main_pipeline(input):\n",
    "\n",
    "    # step 1 select the ROI, and we need to distort the image for fog_video\n",
    "    if video_index == 0:\n",
    "        image = input\n",
    "        top_left = [540, 460]\n",
    "        top_right = [754, 460]\n",
    "        bottom_right = [1190, 670]\n",
    "        bottom_left = [160, 670]\n",
    "    else:\n",
    "        mtx = np.array([[1.15396467e+03, 0.00000000e+00, 6.69708251e+02], [0.00000000e+00, 1.14802823e+03, 3.85661017e+02],\n",
    "                        [0.00000000e+00, 0.00000000e+00, 1.00000000e+00]])\n",
    "        dist = np.array([[-2.41026561e-01, -5.30262184e-02, -\n",
    "                          1.15775369e-03, -1.27924043e-04, 2.66417032e-02]])\n",
    "        image = cv2.undistort(input, mtx, dist, None, mtx)\n",
    "        top_left = [240, 270]\n",
    "        top_right = [385, 270]\n",
    "        bottom_right = [685, 402]\n",
    "        bottom_left = [0, 402]\n",
    "    src_mask = np.array([[(top_left[0], top_left[1]), (top_right[0], top_right[1]),\n",
    "                          (bottom_right[0], bottom_right[1]), (bottom_left[0], bottom_left[1])]], np.int32)\n",
    "    dst_mask = np.array([[(bottom_left[0], 0), (bottom_right[0], 0),\n",
    "                          (bottom_right[0], bottom_right[1]), (bottom_left[0], bottom_left[1])]], np.int32)\n",
    "\n",
    "    # Step 2 Thresholding: color and gradient thresholds to generate a binary image\n",
    "    binary_image = thresholding_pipeline(image, s_thresh=(90, 255))\n",
    "\n",
    "    # Step 3 Perspective transform on binary image:\n",
    "    binary_warped = perspective_transform(binary_image, src_mask, dst_mask)\n",
    "\n",
    "    # Step 4 Fit Polynomial\n",
    "    left_fit, right_fit, lefty, leftx, righty, rightx = sliding_windows(\n",
    "        binary_warped, nwindows=9)\n",
    "\n",
    "    # Step 5 Project Lines\n",
    "    project_lanelines(binary_warped, image, left_fit,\n",
    "                      right_fit, dst_mask, src_mask)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4d7455c9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.image.AxesImage at 0x7fdfeb659eb0>"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAigAAAFHCAYAAACLR7eXAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAvT0lEQVR4nO3df3xU9Z3v8dcEJkOIyTQhkMkIxFSx/ghEDS6QWkHQVK4RrbuK2u2Gan0USyi54lbB7QPcawl1d926pcXrj6VabdO7V3DxoSLhCqHcXFsa5BKwl8VrKoHNbK4WZsKvCSSf+8eRqUNAkpAwZzLv5zw+D8g530y+830kk3fOOd/v8ZiZISIiIuIiaYnugIiIiMipFFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1EhpQfvrTn1JUVMSwYcMoLS3l17/+dSK7IyIiIi6RsIDyq1/9iurqah577DHee+89vvKVrzBz5kz27t2bqC6JiIiIS3gSdbPASZMmcc0117By5crYtssvv5zbb7+dmpqaRHRJREREXGJoIr5oR0cHjY2NPProo3Hby8vLaWho6NY+Go0SjUZjH3d1dfHHP/6RESNG4PF4Bry/IiIicu7MjPb2doLBIGlpn38SJyEB5eOPP6azs5P8/Py47fn5+YRCoW7ta2pqePzxx89X90RERGQAtbS0MHr06M9tk9CLZE89+mFmpz0ismjRIsLhcKx0nYqIiEjyysrKOmubhBxBycvLY8iQId2OlrS1tXU7qgLg8/nw+Xznq3siIiIygHpyeUZCjqCkp6dTWlpKXV1d3Pa6ujrKysoS0SURERFxkYQcQQF46KGH+MY3vsHEiROZMmUKzz77LHv37mXu3LmJ6pKIiIi4RMICyuzZs/nkk0/427/9W1pbWykuLubNN9+ksLAwUV0SERERl0jYOijnIhKJ4Pf7E90NERER6YNwOEx2dvbnttG9eERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdRRQRERExHUUUERERMR1FFBERETEdfo9oCxduhSPxxNXgUAgtt/MWLp0KcFgkIyMDKZNm8auXbv6uxsiIiKSxAbkCMqVV15Ja2trrJqammL7nnzySZ566ilWrFjB1q1bCQQC3HTTTbS3tw9EV0RERCQJDUhAGTp0KIFAIFYjR44EnKMnP/rRj3jssce44447KC4u5sUXX+TIkSP84he/GIiuiIiISBIakICyZ88egsEgRUVF3H333Xz44YcANDc3EwqFKC8vj7X1+XxMnTqVhoaGgeiKiIiIJKGh/f2EkyZN4qWXXuLSSy/lP/7jP3jiiScoKytj165dhEIhAPLz8+M+Jz8/n48++uiMzxmNRolGo7GPI5FIf3dbREREXKTfA8rMmTNj/x8/fjxTpkzh4osv5sUXX2Ty5MkAeDyeuM8xs27bPqumpobHH3+8v7sqIiIiLjXg04wzMzMZP348e/bsic3mOXkk5aS2trZuR1U+a9GiRYTD4Vi1tLQMaJ9FREQksQY8oESjUX7/+99TUFBAUVERgUCAurq62P6Ojg7q6+spKys743P4fD6ys7PjSkRERAavfj/F8/DDD3PrrbcyduxY2traeOKJJ4hEIlRWVuLxeKiurmbZsmWMGzeOcePGsWzZMoYPH869997b310RERGRJNXvAWXfvn3cc889fPzxx4wcOZLJkyfz7rvvUlhYCMD3vvc9jh49yne+8x0OHDjApEmTWL9+PVlZWf3dFREREUlSHjOzRHeityKRCH6/P9HdEBERkT4Ih8NnvVxD9+IRERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHX6XVA2bx5M7feeivBYBCPx8Nrr70Wt9/MWLp0KcFgkIyMDKZNm8auXbvi2kSjUebPn09eXh6ZmZnMmjWLffv2ndMLERERkcGj1wHl8OHDlJSUsGLFitPuf/LJJ3nqqadYsWIFW7duJRAIcNNNN9He3h5rU11dzZo1a6itrWXLli0cOnSIiooKOjs7+/5KREREZPCwcwDYmjVrYh93dXVZIBCw5cuXx7YdO3bM/H6/PfPMM2ZmdvDgQfN6vVZbWxtrs3//fktLS7N169b16OuGw2EDVCqVSqVSJWGFw+Gz/q7v12tQmpubCYVClJeXx7b5fD6mTp1KQ0MDAI2NjRw/fjyuTTAYpLi4ONbmVNFolEgkElciIiIyePVrQAmFQgDk5+fHbc/Pz4/tC4VCpKenk5OTc8Y2p6qpqcHv98dqzJgx/dltERERcZkBmcXj8XjiPjazbttO9XltFi1aRDgcjlVLS0u/9VVERETcp18DSiAQAOh2JKStrS12VCUQCNDR0cGBAwfO2OZUPp+P7OzsuBIREZHBq18DSlFREYFAgLq6uti2jo4O6uvrKSsrA6C0tBSv1xvXprW1lZ07d8baiIiISGob2ttPOHToEB988EHs4+bmZrZv305ubi5jx46lurqaZcuWMW7cOMaNG8eyZcsYPnw49957LwB+v5/777+fhQsXMmLECHJzc3n44YcZP348N954Y/+9MhEREUlePZrX+xkbN2487ZShyspKM3OmGi9ZssQCgYD5fD67/vrrrampKe45jh49alVVVZabm2sZGRlWUVFhe/fu7XEfNM1YpVKpVKrkrZ5MM/aYmZFkIpEIfr8/0d0QERGRPgiHw2e9nlT34hERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER11FAEREREddRQBERERHXUUARERER1+l1QNm8eTO33norwWAQj8fDa6+9Frd/zpw5eDyeuJo8eXJcm2g0yvz588nLyyMzM5NZs2axb9++c3ohIiIiMnj0OqAcPnyYkpISVqxYccY2N998M62trbF688034/ZXV1ezZs0aamtr2bJlC4cOHaKiooLOzs7evwIREREZdIb29hNmzpzJzJkzP7eNz+cjEAicdl84HOaFF17g5z//OTfeeCMAL7/8MmPGjGHDhg189atf7W2XREREZJAZkGtQNm3axKhRo7j00kt54IEHaGtri+1rbGzk+PHjlJeXx7YFg0GKi4tp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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "if __name__ == '__main__':\n",
    "\n",
    "    frames_counts = 1\n",
    "    if video_index == 0:\n",
    "        cap = cv2.VideoCapture('/Users/karantovanatolij/Desktop/project_video.mp4')\n",
    "    else:\n",
    "        cap = cv2.VideoCapture('/Users/karantovanatolij/Desktop/fog_video.mp4')\n",
    "\n",
    "    class MyThread(Thread):\n",
    "\n",
    "        def __init__(self, q):\n",
    "            Thread.__init__(self)\n",
    "            self.q = q\n",
    "\n",
    "        def run(self):\n",
    "            while(1):\n",
    "                if (not self.q.empty()):\n",
    "                    image = self.q.get()\n",
    "                    main_pipeline(image)\n",
    "\n",
    "    q = Queue()\n",
    "    q.queue.clear()\n",
    "    thd1 = MyThread(q)\n",
    "    thd1.setDaemon(True)\n",
    "    thd1.start()\n",
    "\n",
    "    while (True):\n",
    "        start = time.time()\n",
    "        ret, frame = cap.read()\n",
    "\n",
    "        # Detect the lane every 5 frames\n",
    "        if frames_counts % 5 == 0:\n",
    "            q.put(frame)\n",
    "\n",
    "        # Add the lane image on the original frame if started\n",
    "        if started:\n",
    "            frame = cv2.addWeighted(frame, 1, road, 0.5, 0)\n",
    "        cv2.imshow(\"RealTime_lane_detection\", frame)\n",
    "        if cv2.waitKey(1) & 0xFF == ord('q'):\n",
    "            break\n",
    "        frames_counts += 1\n",
    "        cv2.waitKey(12)\n",
    "        finish = time.time()\n",
    "        print('FPS:  ' + str(int(1/(finish-start))))\n",
    "\n",
    "    cap.release()\n",
    "    cv2.destroyAllWindows()\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72ae036c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:tensorflow]",
   "language": "python",
   "name": "conda-env-tensorflow-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.16"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
